#!/usr/bin/perl -w
use strict;

# fabrique dans man les docs spams.<nom>.Rd, a partir des mex*,
# pour les fonctions definies dans un fichier R (r_spams.R par ex)
my $dir = "../../src_release";
my $indent = "    ";
sub usage {
    print "Usage : $0 R-filename\n",
    "   Ex: $0 r_spams\n";
    exit 1;
}

(-d $dir) || die "No dir $dir!\n";
system "rm -rf man"; mkdir "man";
(-d "man") || die "No dir man!\n";
##(-d "html") || die "No dir html!\n";

my ($x,$prog);
my @progs = ();

my $file = "";
while($#ARGV >= 0) {
    $_ = shift(@ARGV);
    (/^-/) && usage();
    ("$file") && usage();
    $file = $_;
}
("$file") || usage();
open(IN,"<$file.R") || die "$file.R open err $!\n";
while(<IN>) {
    chomp;
    if(/^spams\.([^\s<]+)\s*<-/) {
	$prog = $1;
	push(@progs,$prog);
    }
}
close(IN);


@main::keys = ('Name','Description','Usage','Inputs','detail','Output','Author','Note','Examples');
$main::rdformat = {
    'Name' => {'tag' => 'title'},
    'Description' => {'tag' => 'description'},
    'Usage' => {'tag' => 'usage'},
    'Inputs' => {'tag' => 'arguments','prog' => \&parse_args},
    'detail' => {'tag' => 'details', 'optional' => 1,'prog' => \&set_verb},
    'Output' => {'tag' => 'value','prog' => \&parse_args},
    'Author' => {'tag' => 'author'},
    'Note' => {'tag' => 'note', 'optional' => 1},
    'Examples' => {'tag' => 'examples', 'optional' => 1},
};
##@progs = ("SparseProject");

foreach $prog (@progs) {
    my $f = "$dir/mex$prog.m";
    my $fref = "./refman/spams.$prog.in";
    my %doc = ();
    my %modifs = ();
    get_doc($f,$prog,\%doc) || next;
    get_modifs($fref,\%modifs);
    # apply modifs
    apply_modifs(\%doc,\%modifs);
    split_description(\%doc);
    print "++ $prog\n";
    write_man("man/spams.$prog.Rd",$prog,\%doc);
    # make html version
##    system "R CMD Rdconv -t html man/spams.$prog.Rd -o html/spams.$prog.html";
#    print_man("man/spams.$prog.Rd",$prog,\%doc);
}
# copy some specific mans
system "cp ./refman/*.Rd man";

exit 0;

sub get_doc {
    my($f,$prog,$doc) = @_;
    if(! open(IN,"<$f") ) {
	print "ERR $f open err $!\n";
	return 0;
    }
    my $stat = 0;
    my $tmp = [()];
    my $key = "";
    while(<IN>) {
	chomp;
	s/mex$prog/spams.$prog/g;
	if(! $stat) {
	    (s/^%\s*Usage\s*:\s*//) || next;
	    $stat = 1;
	    s/\s*=\s*/ <- /;
	    push(@$tmp,$_);
	    $key = 'Usage';
	    next;
	}
	if(s/^%\s([^\s:]+)\s*:\s*//) {
	    my $x = $1;
	    my $i = $#$tmp;
	    # remove last empty lines
	    while($i >= 0) {
		($$tmp[$i] =~ /^\s*$/) || last;
		$i--;
	    }
	    $#$tmp = $i;
	    $$doc{$key} = $tmp;
	    $tmp = [($_)];
	    $key = $x;
	    if ($x eq "Author") {
		push(@$tmp,"Julien MAIRAL, 2010 (spams, matlab interface and documentation)");
		push(@$tmp,"        Jean-Paul CHIEZE, 2011 (R interface)");
		$$doc{$x} = $tmp;
		last;
	    }
	} else {
	    s/^%\s?//;
	    s/param\.([^\s=,]+)/param[\'$1\']/g;
	    s/Matlab\s+function\s+pcg/R function solve/;
	    s/Matlab\s+expression\s+XAt[^\s\;]+/R expression/;
	    s/Matlab/R/;
	    if($key eq "Usage") {
		s/\s*=\s*/ <- /;
	    }
	    push(@$tmp,$_);
	}
    }
    close(IN);
    1;
}
sub get_modifs {
    my($f,$modifs) = @_;
    my $inblock = 0;
    my ($tmp,$key,$op);
    open(IN,"<$f") || return;
    while(<IN>) {
	chomp;
	(/^\s*$/) && next;
	(/^\s*\#/) && next;
	if($inblock) {
	    if(/^end/) {
		$inblock = 0;
		$$modifs{$key} = { 'op' => $op, 'data' => $tmp};
		next;
	    }
	    push(@$tmp,$_);
	} else {
	    (/^begin\s+([^\s]+)\s+([^\s]+)$/) || next;
	    $op = $1;
	    $key = $2;
	    $tmp = [()];
	    $inblock = 1;
	}
    }
    close(IN);
}
sub apply_modifs {
    my($doc,$modifs) = @_;
    my($op,$tmp);
    while(my ($key,$x) = each(%$modifs)) {
	$op = $$x{'op'};
	$tmp = $$x{'data'};
	if($op eq "repl") {
	    $$doc{$key} = $tmp;
	
	} else {
	    (defined($$main::rdformat{$key})) || next;
	    my $lst = (defined($$doc{$key})) ? $$doc{$key} : [()];
	    if ( $op eq "addfirst") {
	    } elsif ( $op eq "addlast") {
		push(@$lst,@$tmp);
		$$doc{$key} = $lst;
	    } else {
		print "Unknown op $op\n";
	    }
	}
    }
}

# try to split Description into short description end detail
sub split_description {
    my($doc) = @_;
    my $tmp = $$doc{'Description'};
    my $det = [()];
    ($#$tmp < 3) && return;
    for(my $i = 0;$i <= $#$tmp;$i++) {
	my $s = $$tmp[$i];
	if(($s =~ /^\s*$/) || ($s =~ /\.$/)) {
	    my $j = $i;
	    $i++;
	    while($i <= $#$tmp) {
		push(@$det,$$tmp[$i++]);
	    }
	    $$doc{'detail'} = $det;
	    $#$tmp = $j;
	    last;
	}
		
    }
}


sub print_man {
    my($f,$prog,$doc) = @_;
    my($key,$i,$tmp);
    print "** $f\n";
    for($i = 0;$i <= $#main::keys;$i++) {
	$key = $main::keys[$i];
	if(! defined($$doc{$key})) {
	    ($key eq "Note") && next;
	    print STDERR "!! $prog : $key MISSING\n";
	    next;
	}
	$tmp = $$doc{$key};
	print "$key : ", join("\n",@$tmp), "\n";
    }
}

# format value
sub parse_value {
    my($lines) = @_;
    my @res = ();
    ($#$lines >= 0) || return @res;
    my $s = $$lines[0];
    if($s =~ s/^\s*([^\s:])\s*:\s*//) {
	$s = "\\strong{$1} : $s";
    }
    push(@res,$s);
    for(my $i = 1;$i <= $#$lines;$i++) {
	push(@res,$$lines[$i]);
    }
    return @res;
}
sub set_verb {
    my($lines) = @_;
    my @res = ();
    ($#$lines >= 0) || return @res;
    my $s = $$lines[0];
    push(@res,"\\preformatted{$s");
    for(my $i = 1;$i <= $#$lines;$i++) {
	push(@res,$$lines[$i]);
    }
    push(@res,"}");
    return @res;
}


# format input args
sub parse_args {
    my ($lines) = @_;
    my $in_var = 0;
    my @res = ();
    for(my $i = 0;$i <= $#$lines;$i++) {
	my $s = $$lines[$i];
	if($s =~ s/^\s*([^\s:]+)\s*:\s*//) {
	    my $v = $1;
	    if($v eq "param" && $s eq "struct") {$s = "";}
	    if($in_var) {
		push(@res,"}}");
	    }
	    $in_var = 1;
	    push(@res,"\\item{$v}{%",$s,"\\preformatted{%");
	    next;
	}
	push(@res,$s);
    }
    if($in_var) {push(@res,"}}");}
    return @res;
}

sub write_man {
    my($f,$prog,$doc) = @_;
    my($rdf,$i,$key,$tmp);
    open(OUT,">$f") || die "$f create err $!\n";
    print OUT "\\name{spams.$prog}\n\\alias{spams.$prog}\n";
    foreach $key (@main::keys) {
	(defined($$main::rdformat{$key})) || next;
	$rdf = $$main::rdformat{$key};
	if(! defined($$doc{$key})) {
	    if(! defined($$rdf{'optional'})) {
		print STDERR "!! $prog : $key MISSING.\n";
	    }
	    next;
	}
	$tmp = $$doc{$key};
	print OUT "\\$$rdf{'tag'}\{\n";
	if(defined($$rdf{'prog'})) {
	    my $func = $$rdf{'prog'};
	    my @res = &$func($tmp);
	    print OUT join("\n",@res), "\n}\n";
	} else {
	    print OUT join("\n",@$tmp), "\n}\n";
	}
    }
	
    close(OUT);
#    exit;
}
